---
title: "정보처리기사 필기 | 3. 데이터베이스"
date: 2024-02-16 00:00:00 +/-TTTT
categories: [Extracurricular Activities, Certification]
tags: [정보처리기사, database, sql, ddl, view, index, storage, etl, crud]
math: true
toc: true
author: seoyoung
img_path: /assets/img/for_post/
pin: false
description: 데이터베이스 | SQL 응용 및 활용, 논리 데이터베이스, 물리 데이터베이스, 데이터 전환
---

> 자격증 정보처리기사 필기의 "Chapter 3. 데이터베이스" 내용을 요약합니다.
{: .prompt-tip }

`1) SQL 응용`에서는 절차형 SQL 작성과 트리거, 이벤트 프로그래밍, 데이터 조작과 제어 언어를 활용한 DB 관리 방법 등을 소개합니다.

`2) SQL 활용`에서는 SQL을 활용한 데이터 정의와 조작에 대한 SQL 문법, 테이블, 관계형 데이터 모델, 트랜잭션, 데이터 사전, 뷰, 인덱스, 집합 연산자, 조인, 서브 쿼리 등 다양한 SQL 개념을 다루고 있습니다.

`3) 논리 데이터베이스 설계`는 관계 DB 모델 개념과 데이터 모델링, 논리 데이터 모델 품질 검증 방법을 포함합니다.

`4) 물리 데이터베이스 설계`에서는 스토리지의 종류와 개념, 분산 DB와 이중화/암호화, 물리 속성 설계 방법 및 모델링, 품질 검토 방법을 소개합니다.

`5) 데이터 전환`은 데이터 전환 기술과 ETL 개념, 데이터 전환 수행 및 정제 개념을 이야기합니다.



&nbsp;
&nbsp;
&nbsp;

## **1) SQL 응용**

### **<u>절차형 SQL 작성</u>**

#### 트리거 <sup>Trigger</sup>

- DB의 이벤트 프로그래밍으로 일정 조건이 충족될 때 이벤트(데이터 삽입, 수정, 삭제) 등이 발생하는 것
- 사용자가 직접 호출하는 것이 아니라, DB에서 자동으로 호출 실행
- 데이터 무결성 유지와 로그 메세지 출력 등의 처리를 위함

- **<u>기본 문법</u>**
  1. 트리거 선언
  2. **BEFORE**: INSERT, UPDATE, DELETE 문이 실행되기 전 트리거 실행 명령 ㅣ **AFTER**: INSERT, UPDATE, DELETE 문이 실행 후 트리거가 실행됨
  3. **FOR EACH ROW**: 행 트리거 옵션
  4. 필요 SQL 명령어 작성

```
1. CREATE [OR REPLACE] TRIGGER 트리거명
2. [BEFORE | AFTER] ON
3. [FOR EACH ROW]
4. [WHEN (condition)]
    DECLARE(변수선언)
    BEGIN
        {SQL 명령 작성}
        {EXCEPTION}
    END;	
```

&nbsp;
&nbsp;
&nbsp;


- **<u>트리거 명령어</u>**
  - **CREATE TRIGGER**: 트리거 선언
  - **BEFORE**: 트리거 명령 실행 전
  - **DECLARE**: 트리거 명칭
  - **BEGIN ~ END**: 트리거 시작 시 실행 될 명령어 (시작~종료)
  - **CONTROL**: 순차적인 명령어 처리 및 조건에 따른 LOOP
  - **SQL**: 일반적으로 명령 수행 (INSERT, DELETE, UPDATE, SELECT)
  - **EXCEPTION**: 예외 발생 정의
  - **TRANSACTION**: DML 명령의 수행 및 취소 여부 결정
- **트리거 예제**

1. T_SUBJECT (과목) 트리거 명 선언
2. 삽입 (INSERT) 명령어 실행 전
3. 수학 점수가 60점 미만일 경우
4. 에러가 발생
5. 12345번 에러 발생하며 '과락 입니다' 표시 

```
1. CREATE TRIGGER T_SUBJECT
2. BEFORE INSERT ON SUBJECT
	BEGIN
3.	IF(MAT < 60) THEN
4. 	  RAISE_APPLICATION_ERROR
5. 		(-12345, '과락 입니다');
		END IF;
	END;
```


&nbsp;
&nbsp;
&nbsp;


#### 이벤트 <sup>Event</sup>

- **개요**
  - 특정 시간대에 일정 기능을 실행시키는 기능
  - 특정 기능이란 프로시저, 함수, SQL 쿼리 등을 포함함
  - 이벤트가 발생되는 순서를 알면 매크로 또는 이벤트 프로시저가 실행되는 방법 및 시기에 영향을 줌

- **이벤트 기본 문법**

```
1. CREATE EVENT 이벤트명
2. ON SCHEDULE
	[ON COMPLETION [NOT] PRESERVE]
	[ENABLE | DISABLE]
	[COMMENT '주석문']
	DO
	[BEGIN]
		{SQL 명령 작성}
	[END]	
```

&nbsp;
&nbsp;
&nbsp;

- **이벤트 명령어**
  - **CREATE EVENT**: 이벤트 선언
  - **SCHEDULE**: 스케줄 시작
  - **EVERY 간격**
  - **SECOND, MINUTE**: 시간 (초, 분)



- **이벤트 예제**

1. T_EVENT 이벤트 명 선언
2. 스케줄 시작
3. 1분 마다 한번씩
4. INSERT 명령어 실행

```
1. CREATE EVENT T_EVENT
2. ON SCHEDULE
3. 	EVERY 1 MINUTE
4. DO INSERT INTO TEST (ID, PW) VALUES ('park', '1234');
```


&nbsp;
&nbsp;
&nbsp;


#### 사용자 정의 함수

- **<u>SQL DB에서 사용자 정의 함수 개요</u>**

1. SQL 문에서 평가 가능한 함수를 추가함으로써 DB 서버의 기능을 확장하기 위한 장치를 제공
2. 일련의 SQL 명령의 결과를 단일 값으로 변환
3. 사용자가 직접 정의하고 작성 가능
4. SQL 표준은 스칼라와 테이블 함수를 구별
5. 스칼라 함수는 하나의 값 또는 NULL 만을 반환하지만, 테이블 함수는 각 줄이 하나 이상의 열로 된, 0개 이상의 열을 다루는 관계형 테이블을 반환



- **사용자 정의 함수 기본 문법**

1. 사용자 정의 함수 선언
2. 지역 변수 선언
3. 반환 값

```
1. CREATE [OR REPLACE] FUNCTION
2. IS
	BEGIN
3. RETURN [VALUE]
	END;
```

&nbsp;
&nbsp;
&nbsp;

- **사용자 정의 함수 예**

1. MyFunction 함수 선언, ( ) 안은 파라미터 지정
2. 지역 변수 선언
3. SQL 명령 작성
4. 0 값을 리턴

```
1. CREATE FUNCTION MyFunction()
2. IS
	BEGIN
3. SELECT TO ... {SQL 명령 작성}
4. RETURN 0;
	END;
```


&nbsp;
&nbsp;
&nbsp;


#### SQL 문법

- **SQL <sup>Structured Query Language</sup> 문법의 개념**
  - 구조화된 질의 언어
  - DB에 접근하고 조작하는데 필요한 표준 언어
  - 데이터에 대한 SQL을 작성 후 DB에 삽입, 저장, 삭제, 관리 등의 작업 가능
  - 데이터 관리 효율을 높이기 위해 파일 시스템에서 발생할 수 있는 불필요한 데이터의 중복성을 없애고, 여러 응용프로그램에서 공용할 수 있도록 데이터의 독립성을 증대시킨 데이터 집합
- **목적**
  - 중복의 최소화, 데이터 공유, 독립성, 보안성, 일관성
  - **무결성**: 데이터 및 네트워크 보안에 있어서 정보가 인가된 사람에 의해서만 접근 또는변경 가능
- **스키마 <sup>Schema</sup>**
  - DB를 구성하는 파일, 레코드, 속성과 상호관계를 논리적으로 정의한 것
  - 외부스키마, 내부스키마, 개념스키마



- **DB의 디자인 단계**
  - DB의 목적을 정의
  - DB에서 필요한 테이블 정의
  - 테이블에서 필요한 필드를 정의
  - 테이블 간의 관계를 정의
- **DB 필수 기능**
  - 정의 기능, 조작 기능, 제어 기능
- **DB 업무처리 프로그램 개발 순서**
  - 업무 분석 🠊 설계 🠊 프로그램 개발 🠊 테스트 🠊 운용 및 유지보수
- **DB 설계 단계**
  - 요구 조건 분석 🠊 개념적 설계 🠊 논리적 설계  물리적 설계 🠊 구현

&nbsp;
&nbsp;
&nbsp;

- **<u>SQL 문법의 분류</u>**
  - **DB 정의어 <sup>DDL</sup>**
    - CREATE: 테이블 제작
    - ALTER: 테이블의 구조를 변경/수정
    - DROP: 테이블을 삭제
      - RESTRICT: 참조하는 데이터 객체가 존재하면 제거하지 않음
      - CASCADE: 제거 대상을 참조하는 다른 객체도 연쇄삭제
  - **DB 조작언어 <sup>DML</sup>**
    - SELECT: 테이블에서 조건에 맞는 튜플을 검색
    - INSERT: 테이블에 새로운 튜플을 삽입
    - DELETE: 테이블에서 조건에 맞는 튜플을 삭제
    - UPDATE: 테이블의 조건에 맞는 튜플의 내용을 변경
  - **DB 제어어 <sup>DCL</sup>**
    - COMMIT: 작업이 정상적으로 완료되었음을 관리자에게 알림
    - ROLLBACK: 작업이 비정상적으로 종료되었을 때, 원래의 상태로 복구
    - GRANT: DB 사용자에게 사용 권한을 부여
    - REVOKE: DB 사용자의 사용 권한을 취소


&nbsp;
&nbsp;
&nbsp;




### **<u>응용 SQL 작성</u>**

#### 데이터 조작어 <sup>DML, Data Manipulation Language</sup>

- DB 관리 체계에 저장된 자료에 접근하고 조회하기 위한 대화 방식

- 프로그래밍 언어 소스 코드에서 사용될 수 있는 SQL 문장

- **<u>기본 문법</u>**

  - **SELECT**: 테이블에서 조건에 맞는 튜플을 검색

  1. 검색하고자 하는 속성명
  2. 검색할 데이터를 포함하는 테이블명 기술
  3. 조건을 기술 (GROUP BY, HAVING, ORDER BY [ASC ㅣ DESC])

  ```
  1. SELECT 속성명1, 속성명2,...
  2. FROM 테이블명1, 테이블명2, ...
  3. [WHERE 조건]
  ```

  

  - **INSERT**: 테이블에 새로운 튜플을 삽입

  1. 데이터를 삽입할 테이블명 (속성명)
  2. 속성과 1:1 매칭되는 데이터

  ```
  1. INSERT INTO 테이블명 (속성명1, 속성명2, ...)
  2. VALUE (데이터1, 데이터2, ...)
  ```

  

  - **DELETE**: 테이블에서 조건에 맞는 튜플을 삭제

  1. 데이터를 삭제할 테이블 명
  2. 조건을 기술 (GROUP BY, HAVING, ORDER BY [ASC ㅣ DESC])

  ```
  1. DELETE FROM 테이블명
  2. [WHERE 조건]
  ```

  

  - **UPDATE**: 테이블의 조건에 맞는 튜플의 내용을 변경

  1. 업데이트 할 테이블 명
  2. 업데이트 할 튜플의 속성
  3. 조건을 기술

  ```
  1. UPDATE 테이블명
  2. SET 속성명 = 데이터 값
  3. [WHERE 조건]
  ```


&nbsp;
&nbsp;
&nbsp;


#### 데이터 제어어 <sup>DCL, Data Control Language</sup>

- DB에 저장된 데이터를 여러 사용자가 무결성과 일관성을 유지
- 내부적으로 필요한 규칙이나 기법을 정의하는데 사용하는 데이터 언어
- DB를 올바르게 관리하기위해 필요한 규칙과 기법에 따라 DB를 제어하고 보호
- DB 관리자 (DBA)가 데이터의 보안성, 병행성, 무결성, 회복성을 하기위해 사용하는 DB 제어 언어
  - **보안 <sup>Security</sup>**: 허가받은 사용자만 접근 권한이 있는 데이터에 접근 가능
  - **병행성 <sup>Concurrency</sup>**: 여러 사용자가 같은 데이터에 동시에 접근하여 데이터를 처리 가능
  - **무결성 <sup>Integrity</sup>**: 삽입, 삭제, 갱신 등의 연산 후 DB에 저장된 데이터가 정해진 제약 조건을 항상 만족해야함, 즉 DB에는 유효한 데이터만 존재
  - **회복 <sup>Recovery</sup>**: 장애가 발생해도 데이터가 장애 이전의 상태로 복구 가능해야함, 데이터의 일관성이 유지

&nbsp;
&nbsp;
&nbsp;

- **<u>기본 문법</u>**

  - **COMMIT**: 정상완료, 작업이 정상적으로 완료됨, 물리적 디스크로 저장
  - **ROLLBACK**: 비정상 종료, 비정상 종료 시 원래의 상태로 복구
  - **GRANT**: 사용 권한 부여, DB 사용자에게 사용 권한 부여

  1. 테이블에 사용자 권한 부여
     - 권한을 부여받은 사용자는 다른 사람에게 권한을 부여할 수는 없음
  2. 권한 옵션 ㅣ ALL, INSERT, DELETE, UPDATE, SELECT 옵션

  ```
  1. GRANT 권한 ON 테이블명 TO 사용자명
  [WITH GRANT OPTION]
  ```

  - **REVOKE**: 사용 권한 취소, DB 사용자의 사용 권한 취소

  1. 테이블에 사용자 권한 해제
  2. 연쇄 권한 해제 여부 (WITH GRANT OPTION 옵션으로 부여된 사용자들의 권한까지 연쇄 해제 가능)

  ```
  1. REVOKE 권한 ON 테이블명 FROM 사용자명
  2. [CASCADE]
  ```


&nbsp;
&nbsp;
&nbsp;




#### 윈도우 함수 <sup>Window Function</sup>

- **<u>개념</u>**
  - DB의 행과 행간의 관계를 정의하는 함수
  - SQL에 추가된 기능으로 정보 위주의 분석 처리 (OLAP, Online Analytical Processing)을 의미
  - 사용자가 다각도에서 직접 대화식으로 정보를 분석하는 과정
  - 시스템은 단독으로 존재하는 정보 시스템이 아닌, 데이터 웨어하우스, 데이터 마트와 같은 시스템과 상호 연관됨
  - 중간매개체없이 이용자들이 직접 컴퓨터를 이용하여 데이터에 접근하는 데 있어 필수적
  - 집계함수, 순위함수, 행순서 함수, 그룹 내 비율함수

- **<u>기본 문법</u>**

1. 검색할 함수명 (파라미터)
2. RANK(), DENSER_RANK(), LAG(), LEAD() 와 같은 목적 함수 사용
3. OVER는 필수 문구
4. 윈도우: 구분된 레코드 집합
5. ORDER BY는 SORT 입력 ASC (오름차순) / DESC (내림차순)
6. 테이블명

```
1. SELECT 함수명 (파라미터)
2. ......
3. 	OVER
4. 	[PARTITION BY 컬럼1, 컬럼2, ...]
5. 	[ORDER BY 컬럼A, 컬럼B, ...]
6.	FROM 테이블명
```

&nbsp;
&nbsp;
&nbsp;



#### 그룹 함수

- GROUP BY에서 지정할 수 있는 특수 함수
- ROLLUP, CUBE, GROUPING SETS 함수가 있음

- **<u>ROLLUP</u>**

  - 중간 집계 값을 산출하기 위함
  - 지정 컬럼의 수 보다 하나 더 큰 레벨만큼 중간 집계값이 생성
  - **<u>기본 문법</u>**

  1. 집계 대상 컬럼 이름
  2. 테이블명
  3. 조건
  4. GROUP 키워드 여러개를 지정 가능 (HAVING, ORDER BY)

  ```
  1. SELECT 열1 이름, 열2 이름, ...
  2. FROM 테이블명
  3. WHERE 행을 선별하는 조선식
  4. GROUP BY ROLLUP ([그룹화 할 열을 지정])
  ```



- **<u>CUBE</u>**

  - 다차원 집계를 생성하는 그룹 함수
  - 대상 컬럼의 순서를 변경하여 수행
  - 연산량이 많아 시스템에 부담이 큼

  - **<u>기본 문법</u>**

  1. 집계 대상 컬럼 이름
  2. 테이블명
  3. 조건
  4. GROUP 키워드 여러 개를 지정할 수 있음 (HAVING, ORDER BY)

  ```
  1. SELECT 열1 이름, 열2 이름, ...
  2. FROM 테이블명
  3. WHERE 행을 선별하는 조건식
  4. GROUP BY CUBE ([그룹화 할 열을 지정])
  ```


&nbsp;
&nbsp;
&nbsp;


#### 오류 처리 <sup>Error Handling</sup>

- 코드상의 오류나 실행 시 예외나 에러 발생 해결
- 에러가 발생한 문제를 해결하고 의미있는 에러코드를 부여하는 과정
- **<u>에러 코드</u>**
  - **SQLWARNING**: 경고 발생
  - **NOTFOUND**: 다음에 실행될 레코드에 접근을 하지 못했을 때
  - **SQLEXCEPTION**: 에러 발생



&nbsp;
&nbsp;
&nbsp;



## **2) SQL 활용**

### **<u>기본 SQL 작성</u>**

#### 데이터 정의어 <sup>DDL, Data Definition Language</sup>

- **개념**

  - DB 스키마 (스킴)은 데이터 정의 언어라는 특별한 언어로서 표현된 정의의 집합
  - DB의 테이블을 만들고, 구조를 변경하고, 지우는 정의 언어

- **<u>기본 문법</u>**

  - **CREATE**: 테이블 생성

  1. 테이블 생성
  2. 데이터를 비워놓으면 안되는 속성일 경우 NOT NULL
  3. 기본키 속성
  4. 대체키 속성
  5. 외래키 속성
  6. 참조 테이블 (기본 속성)
  7. 제약 조건
  
  ```
  1. CREATE TABLE 테이블명
  	{
  2. 속성명 데이터타입 [NOT NULL]
  3. PRIMARY KEY (속성명),
  4. UNIQUE (속성명),
  5. FOREIGN KEY (외래키 속성명)
  6. REFERENCES 참조테이블 (속성명),
  7. CHECK (조건);
  };
  ```
  
  - **ALTER**: 테이블 구조 변경
  - **DROP**: 테이블 삭제
    - **RESTRICT**: 참조하는 데이터 객체가 존재하면 제거하지 않음
    - **CASCADE**: 제거 대상을 참조하는 다른 객체도 연쇄 삭제


&nbsp;
&nbsp;
&nbsp;


#### 관계형 데이터 모델

- 데이터 간의 관계를 표현하는 데이터 모델
- 개체 집합에 대한 속성 관계를 표현하기 위해 개체를 테이블하고 테이블과 테이블 간의 관계를 연결하는 형태의 데이터 모델
- 데이터간의 관계를 **1:1, 1:N, N:M** 으로 표현
- 데이터간의 관계를 기본키, 외래키 등의 관계로 표현


&nbsp;
&nbsp;
&nbsp;


#### 트랜잭션

- DBMS가 가져야하는 기본적 특성
- 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위
- **<u>특징</u>**
  - **원자성 <sup>Atomicity</sup>**: 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장
  - **일관성 <sup>Consistency</sup>**: 실행을 성공적으로 완료하면 일관성 있는 DB 상태로 유지하는 것 (무결성 제약 조건)
  - **고립성 <sup>Isolation</sup>**: 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장
  - **영속성 <sup>Durability</sup>**: 성공적으로 수행된 트랜잭션은 영속적으로 결과가 반영되어야 함
- **상태 전이도**
  - 시작 🠊 활동 🠊 부분 완료 🠊 실패 🠊 (Rollback) 🠊 철회
  - 시작 🠊 활동 🠊 부분 완료 🠊 (Commit) 🠊 완료


&nbsp;
&nbsp;
&nbsp;


#### 테이블

- 데이터를 저장하는 속성으로 구성된 데이터 집합체
- DB 내에는 여러 테이블이 구성되어 있고 이들간의 관계를 릴레이션이라 함

- **<u>릴레이션 <sup>Relation</sup></u>**
  - **개체 <sup>Entity</sup>와 관계<sup>Relation</sup>로 구성**
    - **개체**: DB가 표현하는 정보로 서로 구별될 수 있는 것을 말함
  - **속성 <sup>Attribute</sup>**: 개체가 가지고 있는 성질을 나타냄
  - **도메인 <sup>Domain</sup>**: 하나의 속성이 가질 수 있는 값의 집합
  - **튜플 <sup>Tuple</sup>**: 테이블의 행을 구성하는 속성 값을 집합
  - **관계 <sup>Relation</sup>**: 는 개체 (테이블) 간의 관계 (상호작용)을 말함
  - **차수 <sup>Degree</sup>**: 테이블을 구성하는 속성의 개수
  - **인스턴스 <sup>Instance</sup>**: 테이블에서 속성을 뺀 나머지 데이터

&nbsp;
&nbsp;
&nbsp;

#### 데이터 사전

- 자료에 관한 정보를 모아두는 저장소
- 자료의 이름, 표현 방식, 자료의 의미와 사용 방식, 다른 자료와의 관계를 저장
- DB의 데이터 사전은 DB 시스템의 내부 스키마, 외부 스키마, 개념 스키마를 포함함
- 데이터를 메타 데이터로 구성함



&nbsp;
&nbsp;
&nbsp;



### **<u>고급 SQL 작성</u>**

#### 뷰

- 하나 이상의 테이블에서 유도된 가상 테이블, 필요한 데이터만 사용자에게 보여주기 위한 테이블
- 뷰의 활용은 일반 테이블과 동일하나 약간의 제약을 가짐
- 삽입, 갱신, 삭제 연산의 제약과 구조를 변경하는 ALTER는 사용 불가능
- 데이터의 논리적 독립성이 보장, 물리적으로 구현된 테이블이 아님
- 전체 테이블에서 필요한 일부 데이터만 공개 (제공) 가능
- **<u>기본 문법</u>**

1. 뷰 테이블 제작
2. 데이터 검색 쿼리문

```
1. CREATE VIEW 뷰 테이블 이름 AS
2. SELECT * FROM 뷰 테이블 이름
```

- **장점**

  - 논리적 데이터 독립성 제공
  - 사용자의 데이터 관리가 편리, 보안성 용이
  - 동일한 데이터를 다양한 포맷으로 표현 가능
  - 사용자의 상이한 요구사항을 지원

- **삭제**

  - 뷰는 일반 테이블과는 달리 구조 변경이 불가능
  - 뷰 이름 변경이 불가능
  - **삭제** 후 다시 만드는 것은 가능

  ```
  DROP VIEW 뷰 테이블 이름
  ```


&nbsp;
&nbsp;
&nbsp;


#### 인덱스

- **개념**
  - DB의 성능에 관련된 중요한 역할
  - DB의 데이터를 빠르게 검색할 수 있는 수단으로 테이블의 속도를 높임
  - 검색한 데이터가 있는 특정 레코드의 위치를 알려줌
  - 데이터의 주소록
- **인덱스 제작**

1. INDEX 제작, UNIQUE (인덱스 데이터의 중복 값 미허용)
2. 정렬은 오름차순 (ASC), 내림차순 (DESC)

```
1. CREATE [UNIQUE] INDEX 인덱스 이름
2. ON 테이블명 (속성명 정렬)
```

- **인덱스 삭제**

```
DROP 인덱스 이름;
```

- **인덱스 구조 변경**

```
ALTER [UNIQUE] INDEX 인덱스 이름
ON 테이블명 (속성명)
```



&nbsp;
&nbsp;
&nbsp;



#### 집합 연산자

- 원래의 데이터와 그 데이터를 유도하는 방법을 기술한 절차적 방법
- 두 개 이상의 테이블의 데이터를 연결하여 하나로 결합
- 두 개 이상의 질의를 하나의 결과로 만들어 줌
- 관계를 처리하기 위해 연산자와 연산 규칙을 제공하는 언어, 검색 질의를 기술
- **<u>일반 집합 연산자</u>**
  - **합집합 <sup>Union</sup>**: 두 릴레이션을 합병
  - **교집합 <sup>Intersection</sup>**: 두 릴레이션에서 공통 튜플을 추출하여 합병
  - **차집합 <sup>Difference</sup>**: 두 릴레이션에서 합병 가능한 튜플의 차집합
  - **카티션 곱 <sup>Cartesian Product</sup>**: 두 릴레이션의 곱을 구함



&nbsp;
&nbsp;
&nbsp;



#### 조인

- 두 개 이상 데이터의 결합, 관계형 DB (테이블)은 교집합의 결과를 가짐
- 두 개 이상의 테이블에서 관련된 튜플을 결합하여 하나의 튜플로 만드는 데이터 연결 방식
- 공통된 속성을 기준으로 하여 두 개의 속성을 하나의 속성으로 만듬
- Cartesian Product + Select Operation
- **<u>조인 관계 연산자</u>**
  - **세타 조인 <sup>Theta Join</sup>**: 선택 연산의 비교 연산자가 =, <, >
  - **동등 조인 <sup>Equi Join</sup>**: Theta Join 중에서 특별히 비교 연산자가 = 인 경우의 연산 속성의 값이 같은 것을 추출
  - **자연 조인 <sup>Natural Join</sup>**: 동등 조인에서 동일한 애트리뷰트 중 하나를 제거하는 연산, 두 개의 테이블에서 같은 속성의 값을 추출
  - **세미 조인 <sup>Semi Join</sup>**: 릴레이션 R과 S를 자연 조인한 결과에 릴레이션 R의 애트리뷰트로 프로젝트한 것



&nbsp;
&nbsp;
&nbsp;



#### 서브 쿼리

- SQL 문 안에 포함된 또 다른 SQL 문
- SQL 문 내부에서 사용하는 SELECT 문
- **메인 쿼리**: 서브쿼리의 결과값을 사용하여 기능을 실행하는 것
- **<u>서브 쿼리 구조</u>**

1. 메인 쿼리 속성명
2. 테이블 명
3. 메인 쿼리 조건, <>= 비고, 서브 쿼리 조건의 속성명
4. 테이블 명
5. 서브 쿼리 조건

```
1. SELECT 속성명1, 속성명2, 속성명3, ...
2. FROM 테이블명
3. WHERE 조건 속성명 < (SELECT 조건 속성명)
4. 					  FROM 테이블명
5. 					  WHERE 속성명 = '속성명의 데이터'
```



&nbsp;
&nbsp;
&nbsp;



## **3) 논리 데이터베이스 설계**

### **<u>관계 데이터베이스 모델</u>**

#### 관계 데이터 모델

- **릴레이션 <sup>Relation</sup>**: 테이블의 행과 열로 구성된 테이블
- **튜플 <sup>Tuple</sup>**: 테이블의 행에 해당되는 데이터 요소
- **속성 <sup>Attiribute</sup>**: 테이블의 열에 해당되는 데이터 요소
- **카디널리티 <sup>Cardinality</sup>**: 튜플의 수
- **차수 <sup>Degree</sup>**: 속성 (Attribute) 수
- **스키마 <sup>Schema</sup>**: 릴레이션 구성의 기본적 요소
- **인스턴스 <sup>Instance</sup>**: 테이블에서 속성을 뺀 나머지 데이터 집합



&nbsp;
&nbsp;
&nbsp;



#### 관계 데이터 언어 (관계 대수, 관계 해석)

- **순수 관계 연산자**
  - **셀렉션 <sup>Selection</sup>**: 특정 조건을 만족하는 튜플의 부분집합 (수평 연산)
    - **SELECT**: 특정 조건 만족 튜플의 부분집합을 수평적 연산의 반환으로 수행
  - **프로젝션 <sup>Projection</sup>**: 특정 속성의 값만 추출 (수직 연산)
    - **PROJECT**: 열의 Subject 조회, 빼기 값을 조회 후 행 값의 반환 수행
  - **디비전 <sup>Division</sup>**: 속성 값의 나눗셈 연산
    - **DIVISION**: 나눗셈, 특정 속성으로 다른 속성값 반환을 수행
  - **조인 <sup>Join</sup>**: 2개의 릴레이션 (테이블) 을 합침



&nbsp;
&nbsp;
&nbsp;



#### 시스템 카탈로그와 뷰

- **시스템 카탈로그**
  - DB 시스템에서 데이터를 읽거나 수정할 때 참고 되는 우선 파일
  - DB 구조에 따라 서로 다른 구조를 가질 수 있음
  - 카탈로그가 생성되면 자료 사전에 저장
  - 카탈로그에 저장된 데이터를 메타 데이터라고 함
  - 테이블의 구조와 정보를 저장
  - 사용자 정보와 위치 투명성 및 중복 투명성을 제공하기 위한 모든 제어 정보를 포함
- **자료 사전 <sup>Data Dictionary</sup>**
  - 데이터 접근 시 필요한 정보를 관리 유지, 시스템만 접근 가능
- **메타 데이터 <sup>Meta Data</sup>**
  - DB의 데이터 관리를 위한 데이터
  - 시스템 카탈로그에 저장된 정보
  - DB의 구조, 제약 조건, 응용, 권한 부여에 관한 내용 포함




&nbsp;
&nbsp;
&nbsp;




### **<u>데이터 모델링 및 설계</u>**

#### 데이터 모델

- 현실 세계의 다양한 데이터 중 조직에 필요한 데이터를 선별하는 과정
- 데이터 모델링은 개념적 데이터 모델링, 논리적 데이터 모델링으로 나뉨
- DB 설계는 개념적 데이터 모델링과 논리적 데이터 모델링을 하는 것
  - **개념적 모델링**
    - 현실 세계에서 데이터를 추출하여 개념 세계로 옮기는 작업
    - 개체-관계 모델, 트랜젝선 인터페이스를 설계, 정규화를 수행
  - **논리적 데이터 모델링**
    - 개념 세계의 데이터를 DB에 저장할 구조로 표현하는 작업
    - 대표적으로 관계 데이터 모델을 이용
    - 저장 공간, 응답 시간, 데이터 효율화 등 여러 가지를 고려하여 설계, 반정규화 수행




&nbsp;
&nbsp;
&nbsp;


#### 개체-관계 (E-R) 모델

- **E-R 다이어그램**
  - 현실 세계를 개념적으로 모델링한 결과물을 그림으로 표현
  - 개념적 구조를 개체-관계 모델 (개체, 속성, 관계)로 표현
  - 사각형, 개체 간 관계를 표현하는 마름모, 개체나 관계의 속성을 표현하는 타원, 각 요소를 연결하는 링크 (연결선) 으로 구성
  - 1:1, 1:N, N:N 관계를 레이블로 표기



&nbsp;
&nbsp;
&nbsp;



#### 논리적 데이터 모델

- E-R 다이어그램으로 표현
- 개념적 구조를 선택한 DB 관리 시스템에 따라 사용자 입장에서 DB에 저장할 형태로 표현한 DB의 논리적인 구조
- 관계 데이터 모델, 계층 데이터 모델, 네트워크 데이터 모델 등이 있음
- **<u>관계 데이터 모델</u>**
  - 논리적 구조가 2차원 테이블 형태
  - 키를 이용하여 관계를 표현
  - 관계형 데이터 모델이라고도 함
  - 일반적 형태 (테이블)의 DB는 관계형 데이터 모델
- **<u>계층 데이터 모델</u>**
  - 논리 구조가 트리 형태, 상하 관계가 존재하는 모델
  - 부모 - 자식 개체, 1:N의 관계만 표현이 가능
  - 개체는 사각형으로 나타내며, 개체들 간의 관계는 링크 (연결선)으로 나타냄
  - 데이터의 삽입, 삭제, 수정, 검색이 쉽지 않은 단점
- **네트워크 데이터 모델**
  - 논리 구조가 그래프 형태
  - 1:N, N:M의 관계를 형성
  - 두 개체 간의 관계를 여러 개 정의할 수 있어 관계를 이름으로 구별
  - 각 관계를 화살표를 이용하여 각 관계를 이름으로 구별 가능
  - 1:N 관계의 개체들을 각각 오너와 멤버라고 부름



&nbsp;
&nbsp;
&nbsp;



#### DB 정규화 <sup>Normalization</sup>

- 데이터의 중복으로 인한 삽입, 삭제, 업데이트 연산 시 이상 현상을 최소화 하여 데이터의 안정성을 최대화
  - **이상 현상**
    - **삽입 이상**: 불필요한 데이터가 같이 삽입
    - **삭제 이상**: 삭제하지 않아야 할 데이터가 연쇄적으로 삭제 됨
    - **업데이트 이상**: 업데이트 시 정보가 모순
- **정규화 단계**

1. **1정규형 (1 NF)**: 도메인 원자값
2. **2정규형 (2 NF)**: 부분 함수 종속 제거
3. **3정규형 (3 NF)**:  이행적 함수 종속 제거
4. **BCNF 정규화 (BCNF)**: 결정자 함수 종속 제거
5. **4정규화 (4 NF)**: 다치 종속 제거
6. **5정규화 (5 NF)**: 조인 종속 제거



&nbsp;
&nbsp;
&nbsp;



### **<u>논리 데이터 모델 품질 검증</u>**

#### 논리 데이터 모델 품질 검증

- 논리 DB의 구성요소와 요소들 간 관계에서 데이터 간의 품질을 검증하기 위한 기준
- 품질 요소는 데이터 값, 구조, 관리 프로세스로 구분됨
  - **데이터 값**: 데이터 현상적 값, 데이터 구조적 값
  - **데이터 구조**: 각 단계별 데이터 구조, 각 조직 단위별 데이터 구조
  - **데이터 관리 프로세스**: 데이터 정의의 프로세스, 데이터 변경 프로세스, 데이터 평가 프로세스




&nbsp;
&nbsp;
&nbsp;




## **4) 물리 데이터베이스 설계**

### <u>물리요소 조사 분석</u>

#### 스토리지

- **SAN (Storage Area Network)**: 스토리지 전용 집중 네트워크
  - 서버와 스토리지 사이 광섬유 채널 <sup>Fiber Channel Switch</sup> 로 저장장치를 연결하는 방식
  - 서로 다른 데이터 저장장치를 연결해 네트워크를 구성, 데이터를 관리
  - 일반 네트워크와는 다른 별도의 네트워크를 전송함, 부하가 적음
  - 광 케이블을 이용하므로 높은 처리속도를 가짐
- **NAS (Network Attached Storage)**: 네트워크 연결 스토리지
  - 네트워크를 통하여 연결하는 방식
  - 파일 시스템을 물리적으로 분사하여 통합 관리하는 저장장치
  - Switch (허브) 라는 물리적인 네트워크 장비가 필요
  - 네트워크로 연결되어 데이터 액세스에 지연 발생으로 속도 저하가 발생 가능
- **DAS (Direct Attached Storage)**: 직접 연결 스토리지
  - 시스템 전용 케이블을 이용하여 직접 부착되어 운영되는 저장 장치
  - 서버에 HBA (Bost Bus Adapter) 를 장착하여 서버와 직접 연결
  - 일반 노트북이나 개인용 컴퓨터에 외장 하드를 직접 붙인 형태
  - 전용 케이블의 사용으로 안정된 성능 보장
  - 저장 장치마다 상이한 접속방법으로 공유에 문제 발생 가능성
  - 저렴하고 데이터 공유가 필요 없을 경우 적합
- **VTL (Virtual Tape Library)**: 가상 테이브 저장 장치
  - 물리적으로는 디스크 저장 장치지만 VTL 엔진으로 인하여 서버에서 테이프 저장장치로 인식됨
  - 데이터의 백업 및 복구를 위해 가상화 기술을 이용
  - 서버 수 만큼 디스크를 분할 해 테이프 라이브러리처럼 사용하여 데이터 복구 및 백업 속도가 테이프보다 빠름



&nbsp;
&nbsp;
&nbsp;



#### 분산 DB

- DB가 물리적으로 분산됨, 시스템 확장성 용이
- 관리상 복잡성이 증가, DB의 메세지 간 교환 문제로 성능이 저하, 개발 비용이 증가
- **<u>투명성</u>**
  - **분할 투명성**: 하나의 논리적 테이블이 여러 단편으로 분할되어 각 단편의 사본이 여러 서버에 저장되어 있음을 알 필요 없음
  - **위치 투명성**: 사용자는 사용하려는 데이터가 어느 서버에 저장되었는지 알 필요가 없음
  - **복제 투명성**: DB 객체가 여러 서버에 물리적으로 저장되어 있는지 알 필요 없음
  - **장애 투명성**: 분산된 DB 중 시스템이나 통신망의 이상 문제가 발생하더라도 데이터의 무결성을 보장할 수 없음
  - **병행 투명성**: 분산된 다수의 DB가 동시에 트랜잭션이 수행되더라도 결과에 이상이 발생하지 않음
- **<u>구성 요소</u>**
  - **분산 처리기**: 컴퓨터 시스템
  - **분산 DB**: 지리적으로 분산되어 있는 DB
  - **통신 네트워크**: 통신망으로 하나의 논리적 시스템으로 연결하는 네트워크 시스템


&nbsp;
&nbsp;
&nbsp;




#### DB 이중화 구성

- 2대 이상의 DBMS를 나눠서 데이터를 저장하는 방식
- 최소 Master 1대, Slave 1대 이상으로 구성
- 실시간 데이터 백업과 여러 대의 DB 서버의 부하를 분산하여 저장
- **<u>이중화 목적</u>**
  - **고 가용성**: 시스템의 정지 없이 서비스가 가동될 수 있는 확률이 높아짐
  - **부하 분산**: 처리를 분산할 경우 하나의 DB를 사용할 때 보다 부하가 줄어들게 되며 전체 성능이 향상
  - **장애 시 손실 최소화**: 장애 시 백업 서버를 운영




&nbsp;
&nbsp;
&nbsp;


#### DB 암호화

- **DB 보안**
  - 무결성은 권한이 있는 사용자로부터 DB를 보호하는 것
  - 보안은 권한이 없는 사용자로부터 DB를 보호하는 것
  - 보안을 위한 데이터 단위는 테이블 전체로부터 데이터 값에 이르기까지 다양
  - 사용자들은 권한에 따라 데이터에 접근이 가능
- **<u>암호화 보안 기술</u>**
  - **암호화**: 데이터에 대한 암호화
  - **키 관리**: 암호화 키에 대한 안전한 관리와 운용
  - **접근 제어와 감사**: 데이터 열람에 대한 접근 제어와 감사

- **<u>DB 암호화 방식</u>**
  - **API 방식**: DB가 아닌 외부 애플리케이션 영역에서 암복호화 수행
  - **플러그인 방식**: DBMS 자체에 플러그인 방식으로 암복호화 모듈을 설치하여 암호화 운영
  - **인플레이스 방식**: 플러그인에서 더 나아가 DB 엔진 내부에서 암복호화 기능을 수행
  - **파일 암호화 방식**: 운영체제 영역의 파일 전체에 암호화를 적용




&nbsp;
&nbsp;
&nbsp;


#### 접근 제어

- 불법적인 데이터 접근을 막아 DB를 보호하는 기법
- DB는 강력한 보안 기능을 제공하며 시스템의 내부에 위치하기에 내부 접근 권한을 가진 사용자의 권한 남용이나 외부 유출이 가장 큰 위협이 됨
- DBMS라는 관리 시스템에 의해 관리되며 인증 과정을 거쳐 로그인하여 정상적으로 접근
- **DB 접근 제어 구성 방법**
  - **게이트웨이 (프록시) 방법**: DB 서버로 접속하는 모든 IP를 DB 보안 서버를 통하도록 설정
  - **스니핑 방법**: 네트워크의 모든 패킷을 분석 로깅하는 방법으로 사후 감사의 의미에 비중을 두는 보안 방식
  - **에이전트 방식**: 서버에 에이전트를 설치하는 방식과 사용자의 클라이언트에 에이전트를 설치하는 방식
- **DB의 보안 요구 사항**
  - 정당한 사용자의 데이터 접근 지원, 추론 방지, 데이터의 무결성 유지, 시스템 감사, 사용자 인증, 데이터 관리와 보호
- **DB 보안 대책**
  - **접근 제어 방법**: 사용자가 DB에 직접적인 경로를 통해서 접근할 때 이를 통제하여 데이터의 보안성을 달성
  - **정보 흐름 제어 방법**: 정보의 분배, 흐름이 발생할 때 권한이 부여되지 않은 데이터 사이에서 부당한 데이터 전달을 통제하는 기술
  - **추론 제어 방법**: 데이터에 간접적인 수단 (추론 채널, 통계 추론) 등으로 부당하게 접근하지 못하도록 통제하는 기술



&nbsp;
&nbsp;
&nbsp;



### **<u>데이터베이스 물리 속성 설계</u>**

#### 파티셔닝

- DB를 여러 부분으로 분할하는 튜닝 기법
- DB의 데이터가 커져서, 조회 시간이 길어질 때 성능이나 가용성 등의 향상을 목적으로 행해지는 것이 일반적
- 분할된 각 부분을 파티션이라고 부름
- 하나의 DB에 몰리던 부하를 분산시켜 성능 향상을 꾀함
- **<u>수평 분할</u>**
  - 하나의 테이블의 각 행을 다른 테이블에 분산시키는 것
  - 하나의 테이블에 남/여가 있을 때 남 (테이블), 여 (테이블)로 분할하여 두 개의 테이블로 나누는 것을 말함
  - 테이블은 2개로 분할되지만, 뷰를 생성하여 하나의 고객 테이블처럼 사용 가능
- **<u>수직 분할</u>**
  - 테이블의 일부 열을 빼내는 형태로 분할
  - 자주 사용되지 않거나 숫자가 많은 열을 다른 장치나 테이블로 따로 만드는 것
  - 올해 데이터, 작년 데이터나 재작년 데이터를 각각 테이블로 분할하여 서비스를 할 경우 사용자는 올해 데이터를 주로 사용함으로 효율적으로 사용 가능
  - 분할된 테이블을 포함하는 뷰를 생성하면 원래의 경우보다 성능이 저하될 수 있음
  - 사용 빈도가 높은 데이터에만 액세스할 경우 성능이 향상
- **<u>파티셔닝 분할 기준</u>**
  - **범위 분할 <sup>Range Partitioning</sup>**: 분할 키 값이 범위 내에 있는지 여부로 구분
  - **목록 분할 <sup>List Partitioning</sup>**: 값 목록에 파티션을 할당, 분할 키 값을 그 목록에 비추어 파티션을 선택
  - **해시 분할 <sup>Hash Partitioning</sup>**: 해시 함수의 값에 따라 파티션에 포함할 지 여부를 결정
  - **합성 분할 <sup>Composite Partitioning</sup>**: 상기 기술을 상황에 따라 결합하여 분할


&nbsp;
&nbsp;
&nbsp;




#### 클러스터링 <sup>Clustering</sup>

- **DB 다중화 (클러스터링) 개념**
  - 데이터를 액세스 하는 시간을 줄이기 위해 자주 사용되는 데이터를 디스크 같은 위치에 저장
  - 데이터 조회 성능을 향상 시키지만 저장, 수정, 삭제 등의 부하는 증가
  - 분포도가 넓을 수록 좋고 저장 공간의 절약도 가능
- **단일 클러스터링**
  - 클러스터에 하나의 테이블만을 생성
  - 같은 클러스터 컬럼 값을 가진 로우는 같은 장소에 저장되므로 넓은 범위의 데이터를 동시에 액세스하고자 할 때 주로 활용
- **다중 클러스터링**
  - 단위 클러스터에 두 개 이상의 테이블을 함께 저장하는 것
  - 같은 클러스터 키 컬럼 값을 가진 각 테이블의 로우는 정해진 장소에 같이 저장되므로 테이블 조인 속도를 향상시킬 때 사용


&nbsp;
&nbsp;
&nbsp;




#### DB 백업

- DB의 데이터가 손실 될 경우를 대비하여 데이터를 저장, 문제 발생시 복구를 위한 복사본 제작
- **<u>백업 방법</u>**
  - **전체 백업 <sup>Full Backup</sup>**: 모든 데이터 파일을 백업하고 진행되는 동안의 기록된 트랜잭션 로그를 백업
  - **차등 백업 <sup>Differential Backup</sup>**: 가장 마지막 백업 이후에 변경된 데이터만 백업
  - **트랜잭션 로그 백업 <sup>Transaction Log Backup</sup>**: 트랜잭션 로그 파일을 백업하고 로그를 지움
- **<u>복구 방법</u>**
  - **단순 복구**: 마지막으로 백업을 시행한 시점까지의 백업된 정보를 복구
  - **전체 복구**: 문제가 발생한 시점이나 과거의 백업을 받은 특정 시점까지의 정보를 복구

&nbsp;
&nbsp;
&nbsp;

- **백업 기본 문법**

1. 백업할 DB
2. 백업할 DB 저장 경로

```
1. BACKUP DATABASE DB명
2. TO DISK = '경로명'
```

- **파일 또는 파일 그룹 백업 기본 문법**

1. 백업할 DB
2. 논리 파일 또는 논리 그룹 명
3. 백업 DB 저장 경로

```
1. BACKUP DATABASE DB명
2. FILE = '논리 파일 이름' | FILEGROUP = '논리 파일 그룹 명'
3. TO DISK = '경로명'
```

- **차등 백업 기본 문법**

1. 백업할 DB
2. 경로명
3. 차등 옵션

```
1. BACKUP DATABASE DB명
2. TO DISK = '경로명'
3. WITH DIFFERENTIAL
```

- **트랜잭션 로그 백업**

1. 로그 백업할 DB
2. 백업 DB 저장 경로

```
1. BACKUP LOG DB명
2. TO DISK = '경로명'
```



&nbsp;
&nbsp;
&nbsp;



#### 테이블 저장 사이징

- 저장 용량을 예측하여 효과적으로 사용하기 위한 것
- 확장성 및 가용성을 높일 수 있음
- 병목 현상을 최소화
- **<u>저장 공간 용량 설계</u>**
  - 수집할 데이터 크기 및 최대 저장기간 등을 고려하여 용량 설계
  - 관계형 DB는 레코드 최대 크기 등을 고려하여 저장 공간 용량 설정
  - 관계형 DB는 솔루션 별 가용공간이 다르므로 솔루션 업체별 설계 가이드를 참고하여 Scale-up, Scale-out 방식으로 최대 TeraByte 씩 확장 가능
  - NoSQL 및 분산 파일 시스템은 Scale-out 방식으로 PetaByte 이상 확장 가능
- **데이터 저장 스케일**
  - **스케일 아웃**: 접속된 서버의 대수를 늘려 처리 능력을 향상
  - **스케일 업**: 서버 자체를 증강하여 처리 능력을 향상



&nbsp;
&nbsp;
&nbsp;



#### 데이터 지역화 <sup>Locality</sup>

- 데이터를 수집한 지역에서 관련 데이터를 저장 및 처리하는 정책
- 데이터를 가까운 지역에 저장하는 것



&nbsp;
&nbsp;
&nbsp;



### **<u>물리 데이터베이스 모델링</u>**

#### DB 무결성

- 권한이 있는 사용자에 의해 발생 가능한 오류를 방지하기 위함
- 데이터를 정확하고 유효하게 유지하기 위함, 제약 조건에 의해 무결성 유지
- 무결성 규정에는 규정 이름, 검사 시기, 제약 조건 등을 명시

- **<u>제약 조건</u>**
  - **개체 무결성 제약 조건**
    - 후보키 중 튜플 선택을 위한 특별한 키
    - 중복될 수 없으며 NULL 값을 가질 수 없음
  - **참조 무결성 제약 조건**
    - 외래키에 의한 규칙, 중복 가능, NULL 값 가능
- **<u>무결성 종류</u>**
  - **NULL 무결성**: 릴레이션의 특정 속성 값이 NULL이 될 수 없도록 하는 규정
  - **고유 무결성**: 릴레이션의 특정 속성에 대해 각 튜플이 갖는 값들이 서로 달라야 하는 규정
  - **참조 무결성**: 외래키 값은 NULL이거나 참조 릴레이션이 기본키의 값과 동일해야 한다는 규정
  - **도메인 무결성**: 특정 속성의 값이 그 속성의 정의된 도메인에 속한 값이어야 한다는 규정
  - **키 무결성**: 하나의 테이블에는 적어도 하나의 키가 존재해야 한다는 규정



&nbsp;
&nbsp;
&nbsp;



#### 칼럼 속성

- **컬럼**: 테이블에서 특정한 단순 자료형의 일련의 데이터 값과 테이블에서의 각 열을 말함
  - 열이 어떻게 구성되어야 할지에 대한 구조 제공
  - 컬럼과 같은 의미로 사용되는 것은 속성 <sup>Attribute</sup>
- **<u>데이터 타입</u>**
  - **CHAR `n`**: 고정 길이 데이터 타입 (~255byte)
  - **VARCHAR `n`**: 가변 길이 데이터 타입 (~65535byte)
  - **TEXT `n`**: 문자열 데이터 타입 (~65535byte)
  - **INT `n`**: 정수형 데이터 타입 (4byte, -2147483648 ~ +2147483647)
  - **FLOAT `소수`**: 부동 소수형 데이터 타입, 고정 소수점 사용 형태 (4byte)
  - **DOUBLE `소수`**: 부동 소수형 데이터 타입 (8byte)
  - **DATE `년/월/일`**: 날짜 형태의 기간 표현 데이터 타입 (3byte)
  - **TIME `시/분/초`**: 시간 형태의 기간 표현 데이터 타입 (3byte)

&nbsp;
&nbsp;
&nbsp;



#### 키

- 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성
- 유일성과 최소성 특성
- 특성에 따라 기본키, 외래키, 후보키, 대체키, 슈퍼키 등의 종류
- **<u>특성</u>**
  - **유일성**: 각 튜플을 유일하게 식별할 수 있는 특성
  - **최소성**: 유일하게 식별가능한 속성이 최소로 구성된 특징
- **<u>종류</u>**
  - **기본 키 <sup>Primary Key</sup>**
    - 후보 키 중 튜플 선택을 위한 특별 키
    - 중복될 수 없으며 NULL 값을 가질 수 없음
    - 유일성과 최소성 모두 만족
  - **후보 키 <sup>Candidate Key</sup>**
    - 각 튜플을 구별하는 기준이 되는 속성 집합
    - 기본 키가 될 수 있는 성질을 가지고 있는 키
    - 유일성과 최소성 모두 만족
  - **대체 키 <sup>Alternate Key</sup>**
    - 키 중에서 기본키를 뺀 나머지 키
    - 후보키 중 기본키로 선택되지 않은 키
    - 유일성과 최소성 모두 만족
  - **외래 키 <sup>Foreign Key</sup>**
    - 다른 테이블을 참조하기 위해 사용
    - 외래키는 참조 릴레이션 (테이블) 의 기본 키여야 함
  - **슈퍼 키 <sup>Super Key</sup>**
    - 테이블에서 기본 키를 만족하는 키가 없을 때 두 개 이상의 속성으로 구성
    - 하나의 테이블 내에 있는 두 개 이상의 속성 집합으로 구성
    - 유일성은 만족하지만 최소성은 만족하지 않음



&nbsp;
&nbsp;
&nbsp;



#### 반 정규화

- **반 정규화와 역 정규화**
  - 정규화 된 DB에서 성능을 개선하기 위해 사용
  - 정규화함으로써 성능상 문제가 발생했을 경우 일부 이상 증세의 손실을 감수하고 정규화 과정을 반대로 수행
  - 정규화된 테이블에 대해 시스템의 성능 향상과 개발/운영 단순화를 위해 중복, 통합, 분리 등을 수행
  - DB의 성능과 단순화 중 어느 것을 우선으로 할지를 조정



&nbsp;
&nbsp;
&nbsp;



### **<u>물리 데이터 모델 품질 검토</u>**

#### 물리데이터 모델 품질 기준

- 시스템 성능에 직접적인 영향을 미치므로 향후 발생할 문제에 대해 검토해야 함
- DB 성능 향상과 오류 예방이 목적
- 모델의 품질 기준은 상황이나 여건에 따라 가감하거나 변형하여 사용하기도 함
- 객체를 새성한 후 개발 단계로 넘어가기 전에 수행

- **<u>기준 항목</u>**
  - **정확성**: 데이터 모델이 표기법에 따라 정확히 표현되었고, 업무 영역 또는 요규사항이 정확히 반영됨
  - **완전성**: 데이터 모델의 구성 요소를 정의하는데 있어 누락을 최소화하고 요구사항 및 업무 영역 반영에 있어서 누락이 없음을 의미
  - **준거성**: 제반 준수 요건들이 누락 없이 정확히 준수되었음
  - **최신성**: 데이터 모델이 현행 시스템의 최신 상태와 이슈를 지체없이 반영함
  - **일관성**: 여러 영역에서 공통 사용되는 데이터 요소가 전사 수준에서 한번만 정의되고, 이를 다른 영역에서 참조/활용되면서 모델 표현상의 일관성을 유지하고 있음
  - **활용성**: 작성된 모델과 그 설명 내용이 이해 관계자에게 의미를 충분히 전달할 수 있으며, 업무 변화 시 설계 변경이 최소화 되도록 유연하계 설계



&nbsp;
&nbsp;
&nbsp;



#### 물리 E-R 다이어그램

- 논리 설계단에서는 엔티티와 엔티티타입, 관계를 정의
- 물리 설계단에서는 각 엔티티 관계에 의해서 나올 수 있는 테이블을 설계
- 물리 모델은 논리 모델이 실제 DBMS에 적용시키는 상세화 과정
- DB 생성 계획에 따라 객체, 인덱스를 생성
- **<u>모델링 단계</u>**
  - **개념적 모델링**: 개체와 개체들 간의 관계에서 E-R 다이어그램을 만드는 과정
  - **논리적 모델링**: E-R 다이어그램을 사용하여 관계 스키마 모델을 만드는 과정
  - **물리적 모델링**: 관계 스키마 모델의 물리적 구조를 정의하고 구현하는 과정



&nbsp;
&nbsp;
&nbsp;



#### CRUD 분석

- **생성 <sup>Create</sup>, 읽기 <sup>Read</sup>, 갱신 <sup>Update</sup>, 삭제 <sup>Delete</sup>** 를 뜻함
- 테이블에 변화를 주는 트랜잭션의 CRUD 연산에 대해 CRUD 매트릭스를 작성하여 분석
- **검증 내용**
  - 하나의 프로세스가 엔티티 타입과 속성, 관계에 대해 어떠한 영향을 미치는가를 검증
  - 어떤 프로세스가 엔티티 타입을 이용하는지 검증
  - 엔티 티타입이 상호 연관되는 관계에 대해 연결되어야 하는지 끊어야 하는지를 검증
- **<u>CRUD 구성 요소</u>**
  - **엔티티 타입**: 프로세서에 영향을 받는 데이터 (튜플)
  - **단위 프로세서**: 엔티티에 영향을 주는 업무 단위 (ACID)
  - **CRUD**: 프로세서가 엔티티에 주는 영향



&nbsp;
&nbsp;
&nbsp;



#### SQL 성능 튜닝

- SQL문을 최적화 하여 빠른 시간에 최적의 결과를 얻기 위함
- DB 튜닝 과정에서 발생한 문제는 대부분 SQL 튜닝으로 해결하며, 튜닝에 따라 성능에 큰 차이
- **<u>절차</u>**
  - 문제 인식 🠊 튜닝 정보 수집 🠊 수집된 정보 분석 🠊 문제 해결 방안 제시 🠊 시험 및 적용 



&nbsp;
&nbsp;
&nbsp;





## **5) 데이터 전환**

### **<u>데이터 전환 기술</u>**

#### 초기 데이터 구축

- **물리 데이터 모델 품질 기준 개념**
  - 시스템의 데이터를 목표 시스템의 데이터 구조에 맞게 매핑
  - 데이터를 전환하는 규칙을 정의하고 추출, 변화하여 이관
- **<u>데이터 전환 방식</u>**
  - **빅뱅 방식**
    - 일괄적으로 데이터를 새로운 시스템으로 전환/이행, 통합성과 무결성 유지 용이
    - 전환 방식에 대한 노하우가 많음, 일괄적으로 데이터를 신 시스템으로 전환/이행
    - 이행시간이 상대적으로 빠름
    - 전환 시 시스템 업무의 OFF가 필요하며 대량 시스템 자원이 소모
    - 사전 충분 테스트/검증이 필요
  - **단계적 방식**
    - 우선 전환 데이터를 통한 선결 문제점을 보완 적용
    - 우선 순위를 정하여 단계적으로 데이터 전환/이행, 전환 시 시스템 자원이 적게 소요 but 많은 비용 소모
    - 서브 시스템이 여러 번 가동되므로 사용자의 혼란을 초래
  - **빅뱅 + 단계적 전환 방식**
    - 전환 비용이 상대적으로 적게 소모, 업무를 완전히 중단할 필요 없음
    - Cut-Off 시간이 빅뱅방식에 비해 짧음, 데이터 무결성 유지가 어려움
    - 미반영 트랜잭션 반영을 위해 반영 프로그램이 이중 개발되어야 함

&nbsp;
&nbsp;
&nbsp;

- **데이터 전환 절차**

1. 현행 데이터에 대한 철저한 분석을 수행
2. 데이터를 정비
3. 전환 프로그램 개발
4. 데이터 전환 시험 수행
5. 이행 계획 수립



&nbsp;
&nbsp;
&nbsp;



#### ETL <sup>Extraction, Transformation, Loading</sup>

- **Extract**: 대상이 되는 테이블에서 모든 형태의 데이터를 전부 추출 ㅣ ex. 년-월-일-시-분-초
- **Transform**: 추출한 데이터를 요구하는 형태로 변경 ㅣ ex. 연월일 / 시분초
- **Load**: 변경이 된 데이터를 새로운 테이블에 적재
- **<u>개념</u>**
  - 추출, 변환, 적재는 컴퓨팅으로 부터 DB 데이터 웨어하우스에서 데이터 전환을 하는 프로세스
  - 동일 기종 또는 타 기종의 데이터 소스로부터 데이터 추출
  - 추출된 데이터를 변환, 적재하는 작업을 거쳐 목적 시스템으로 전송 및 로딩
  - 목적 대상으로는 DB, 특히 운영 데이터 스토어, 데이터 마트, 데이터 웨어하우스가 있음



&nbsp;
&nbsp;
&nbsp;



#### 파일 처리 기술

- 데이터를 저장하는 기술, 기억 공간을 효율적으로 사용하고 자료를 쉽게 검색 가능
- **<u>파일 처리 기술</u>**
  - **순차 파일 <sup>Sequential File</sup>**
    - 레코드의 논리적 순서에 따라 물리적 순서대로 레코드를 저장하는 방법
    - 변동 사항이 크지 않는 일괄 처리 방식에 사용, 자기 테이프에서 사용
  - **색인 순차 파일 <sup>Indexed Sequential File</sup>**
    - 키 값에 따라 정렬된 레코드를 순차적으로 접근
      - **ISAM <sup>Indexed Sequential Access Method</sup>**: 순차적으로 정렬된 데이터 파일과 키들로 된 인덱스로 구성
        - 데이터 파일 (기본 구욕, 오버플로 구역)과 인덱스 (마스터, 실린더, 트랙) 구성, 정적 인덱스
      - **VSAM <sup>Virtual Storage Access Method</sup>**: 데이터 파일과 인덱스 (B+-트리) 는 블록으로 구성
      - 제어 구간, 제어 구역, 순차 세트, 인덱스 세트로 구성, 동적 인덱스
  - **직접 파일 <sup>Direct File</sup>**
    - 레코드 키 값을 입력으로 해상 함수를 통해 레코드의 물리적 주소로 직접 접근
    - 특정 순서 없이 물리적 저장 공간에 기록, 기억 공간의 효율이 저하




&nbsp;
&nbsp;
&nbsp;




### **<u>데이터 전환 수행</u>**

#### 데이터 전환 수행 계획

- 데이터 통합은 기존의 Legacy System의 데이터를 추출, 신규 시스템에 적합한 형식과 내용으로 변환
- 신규 시스템템에 올리는 일련의 과정, 안정적으로 이행할 수 있도록 데이터 통합을 위한 이행 전략을 가지고 수행
- **데이터 통합 기술**
  - **자동화된 데이터**: 프로젝트의 위험 부담 제거 및 현업 적용시간 단축
  - **데이터 품질 관리**: 데이터의 무결점 운영과 데이터 오류와 불일치를 표준화, 통합을 위한 여건 마련
  - **데이터 가공 (ETL) 기술상 진보**: 상이한 데이터 통합과 애플리케이션 도입으로 시간 절약 및 개발자 생산성 향상
  - **엔드 투 엔드 메타 데이터 관리**: 메타 데이터 표준과 정의를 사용자에게 제공하여 데이터를 이해 가능하도록 지원
  - **병렬처리 및 실시간 통합**: 병렬 처리 기술의 발전 및 구현 용이성 증대
- **데이터 현황 범위**
  - **파일**: 파일 타입별, 용도별 사용 현황
  - **DB**: 업무별 현황
  - **백업**: 백업 주기 별 현황 파악과 복구 방법 파악
- **데이터 감사 및 검증 방안**
  - 데이터 이행 과정에서 데이터의 유효성, 완전성 검사를 통해 이행되어야 할 데이터를 사전에 검증
  - 이행된 데이터에 대해서도 지속적으로 품질 측정


&nbsp;
&nbsp;
&nbsp;




#### 체크 리스트

- 전환 프로그램의 여러 요소를 고려한 측정 가능 목록
- 수행 작업의 상세 항목, 시간, 작업자를 기재
- 데이터 이행 시 리스크 및 대책 기재
- **데이터 이행 사전 작업**
  - 기존 데이터 정비 및 검증
  - 목표 DB 환경 설정 및 구현
  - 데이터 이행 우선순위 결정
  - 데이터 이행 검증 기준 마련
  - 데이터 이행 도구 훈련
- **<u>데이터 전환 체크리스트</u>**
  - **사전 작업**: 운영 환경 점검, 인프라 점검, DB 점검
  - **전환 단계**: 테이블 이관 작업, 테이블 정제 및 변환
  - **점검 단계**: 전환 요건 항목 검증, SQL 대상 후속 조치



&nbsp;
&nbsp;
&nbsp;



#### 데이터 검증

- 데이터 이행에 대한 사전 작업
- 기존 데이터의 정비 및 검증, 테이블의 매핑 관계 설정 및 구현, 데이터 이행의 우선 순위 결정, 데이터 이행의 검증 기준 마련
- 데이터의 정합성을 확보하고 데이터 품질의 유지/개선 작업을 수행하기 위해 기본적으로 관리되어야 할 데이터를 의미
- 데이터의 비효율적 사용을 예방, 데이터의 운용 중 발생가능한 데이터 품질 저하 예방
- 운용 시스템 전반의 데이터를 고품질로 유지
- **데이터 품질 관리 전략**
  - 데이터의 정합성, 일치성, 적시성, 유형성 파악
  - 데이터의 오류 유형에 대한 파악
  - 정보의 유효성 검정 <sup>Validity Certification</sup> 및 보증 평가
  - 오류 데이터에 대한 계량화 작업 수행
- **품질 관리 기준**
  - **품질 기준**: 데이터의 중요도에 따라 등급을 두어 관리
  - **품질 점검 주기**: 사용자의 요구 수준을 반영하여 정기적 및 지속적으로 수행
  - **품질 검증 절차와 규칙 정의**
  - **품질 개선 절차**: 데이터 품질 개선을 위한 관리 절차와 방법 정의




&nbsp;
&nbsp;
&nbsp;




### **<u>데이터 정제</u>**

#### 데이터 정제

- 데이터 전환에서 발생가능한 오류 및 문제 해결을 위한 내용 작성, 의사결정에 도움을 줌
- 오류 관리 목록의 각 항목에 대해 정제 유형을 분류하고 현재 상태를 정의
- 데이터 정제 검토 시 신속한 의사 결정을 위한 오류사항의 해결 방안을 포함
- 데이터 정제 요청서를 통해 정제된 원천 데이터가 정상적으로 정제되었는지 확인한 결과를 작성
- **<u>데이터 정제 대상</u>**
  - **정합성 미지**: 데이터 상호 간의 동일한 정보가 서로 불일치 하는 경우
  - **불필요한 데이터 필드**: 사용하지 않는 필드에 데이터 값이 존재하는 경우
  - **손실된 데이터**: 저장된 필드의 사이즈가 작아 일부 데이터가 손실
  - **불일치 데이터 타입**: 숫자형 필드에 영문자 또는 한글이 존재
  - **오류 데이터**: 년도 데이터 등이 문자나 숫자 등으로 통일되지 않거나 윤년 등이 감안되지 않는 경우
- **전환 과정에서의 정제**
  - 오류의 유형이 일정하고 단순하게 수정 가능
  - 일정한 로직에 의해 수정 가능
  - 현재는 알 수 없으나, 매핑 값을 알 수 있는 경우
  - 지정된 값으로 일괄 수정이 가능한 경우
  - 기타 매핑 과정에서 수정이 필요한 경우


&nbsp;
&nbsp;
&nbsp;


#### 데이터 품질 분석

- 각기 다른 타입의 데이터가 존재하여 전형적인 품질 문제를 야기
- 서술 데이터 <sup>Descriptive Data</sup>, 장기 데이터 <sup>Longitudinal Data</sup>, 스트리밍 데이터 <sup>Streaming Data</sup>, 웹 스크랩 데이터 <sup>Web Scraped Data</sup>, 수치 vs 범주 vs 텍스트 데이터
- 데이터의 용도는 다양, 용도를 모를 경우 해당 데이터가 쓸모없는 경우도 있음
- **프로세스 관리 방법**
  - 품질 문제를 돈으로 환산, 내용과 형식 표준화, 데이터 모니터링, 데이터를 한번만 정확히 입력, 자동화
- **통계적 접근 방법**
  - 수집된 정통적인 통계 데이터가 종종 분석에 사용
  - 데이터의 이상을 찾고 수정하는데 적용 가능한 기존 방법
    - 분실된, 불완전한, 모호한, 훼손된 데이터, 의심스러운 비정상 데이터, 모델로부터 일탈에 대한 테스팅
- **기술적 접근 방법**
  - 적절한 절차를 보증, 데이터에 있는 이상을 찾아서 수정함
  - 일관성을 보증


&nbsp;
&nbsp;
&nbsp;




#### 오류 데이터 측정

- **오류 데이터 측정 개념**
  - 데이터에 따라 정상/오류 데이터로 나뉨
  - 정형, 비정형 데이터 유형대로 규칙에 위반되는 오류 데이터의 발생과 건수를 추출
  - 규칙에 따라 데이터 품질 기준을 산출
  - 각 분류 별 발생되는 오류는 데이터 또는 응용 시스템 보정을 통해 해결 가능
- **오류 데이터 산출물**
  - 업무 규칙별 오류율 현황, 핵심 데이터별 오류율 현황, 데이터 유형별 품질 지수 현황





